breed [clause-sets clause-set]
directed-link-breed [dpll-links dpll-link]

clause-sets-own [
  #clause-content
  #clause-active?
  #clause-sat?
  depth ; for use in the tree representation
]

dpll-links-own [ var ]

; DPLL report: receives a set of clauses (each clause is a set (list) of
; literals, and the clause-set y a list of lists), and a #debub boolean
; to indicate if the process will be shown or not.

to-report dpll [S #debug]
  no-display
  ; Create the initial clause-set
  create-clause-sets 1 [
    set shape "box"
    set color yellow
    set size 3
    set #clause-content S
    set label-color black
    set #clause-active? true
    set depth 0
  ]
  ; The main loop, while there are active clauses to process
  while [any? clause-sets with [#clause-active?]] [
    ; Take clauses to be processed
    ask clause-sets with [#clause-active?] [
      ; Take its units
      let units filter [c -> length c = 1] #clause-content
      ; if there are units
      ifelse not empty? units
      [
        set units (reduce sentence units)
        ; Create a new clause-set with the application of unit propagation of units
        ; all the units are propagated in one step
        hatch-clause-sets 1 [
          set size 2
          foreach units [
            u ->
            set #clause-content filter [c -> not member? u c] #clause-content
            set #clause-content map [c -> ifelse-value (member? (neg u) c) [remove (neg u) c] [c]] #clause-content
            set depth depth + 1
          ]
          ; Decide if the new clause is a final one:
          ; ... and if it produces a model
          if empty? #clause-content[
            set #clause-active? false
            set #clause-sat? true
            set color green
          ]
          ; ... or is a closed one
          if member? [] #clause-content [
            set #clause-active? false
            set #clause-sat? false
            set color red
          ]
          ; and connect it with the previous clause
          create-dpll-link-from myself [
            set var units
            set label var
            set label-color black
          ]
        ]
      ]
      ; if there are no units
      [ 
        ; take one of their propositional variables
        let vp first first #clause-content
        ; and divide the process with both literals
        foreach (list vp (neg vp)) [
          v ->
          hatch-clause-sets 1 [
            set size 2
            set depth depth + 1
            set #clause-content lput (list v) #clause-content
            ; connect with the previous clause
            create-dpll-link-from myself [
              set var v
              set  label var
              set label-color black
            ]
          ]
        ]
      ]
      ; after applying this step, this clause set is not active
      set #clause-active? false
    ]
  ]
  ; Show the built tree if #debug
  ifelse #debug 
  [ ]
  [ ask clause-sets [hide-turtle]
    ask dpll-links [hide-link]
  ]
  display
  ; report if the set is satisfiable or not
  report (any? clause-sets with [#clause-sat? = true])
end

; Auxiliary prodecure to negate a literal
to-report neg [u]
  ifelse (first u) = "-" 
  [report bf u]
  [report (word "-" u)]
end
