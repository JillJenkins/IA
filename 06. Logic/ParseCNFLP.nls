extensions [cf]

__includes ["LayoutSpace.nls"]

breed [formula-nodes formula-node]
directed-link-breed [formula-links formula-link]

formula-nodes-own [depth]

;--------------------------------------------------------------------
; Parse formulas as trees
;--------------------------------------------------------------------


; Transform  a fÃ³rmula (as a string) into a tree (list of lists) 
; In this tree, operators are in the head of the list
;
; Operators: - (neg), & (and), | (or), -> (if), <-> (iff)
;
; The input format is very restrictive:
;   - It needs ALL the perenthesis (also the negation)
;   - It doesn't allow associative operators (must be written as 
;     a combination of binaries operations)
;
; Some examples:
;  ParseLP:to-tree "((a->b)|(-c))" : ["|" ["->" "a" "b"] ["-" "c"]]
;  ParseLP:to-tree "(a <-> (b|c))" : ["<->" "a" ["|" "b" "c"]]

to-report ParseLP:to-tree [s]
  set s ParseLP:remove-spaces s
  set s ParseLP:replace-all "(" s "["
  set s ParseLP:replace-all ")" s "]"
  set s ParseLP:string-to-list s
  set s read-from-string s
  report ParseLP:OptoHead ParseLP:Sep s
end

; Separate recursively brackets and operators by using ParseLP:SepConn
; "ParseLP:Sep [[[["-a"] "&b"] "->c"] "<->" ["a|b"]] ==
;                       [[[["-" "a"] "&" "b"] "->" "c"] "<->" ["a" "|" "b"]]
to-report ParseLP:Sep [s]
  (cf:ifelse
    empty? s [report []]
    is-list? (first s) [report fput (ParseLP:Sep  first s) (ParseLP:Sep bf s)]
    [report (sentence (ParseLP:SepConn first s) (ParseLP:Sep bf s))])
end

; Move operators to head of lists
to-report ParseLP:OptoHead [l]
  (cf:ifelse
    is-string? l [report l]
    length l = 1 [report (first l)]
    length l = 2 [report map ParseLP:OptoHead l]
    length l = 3 [report map ParseLP:OptoHead (list (item 1 l) (item 0 l) (item 2 l)) ])
end

; Separate in a single string the operators from the operands:
; ParseLP:SepConn "aa&bb" = "aa" "&" "bb"
; returns a list

to-report ParseLP:SepConn [s]
  let rep ""
  let ls length s
  (cf:ifelse
    member? "<->" s [ let pos position "<->" s
                      set rep  (list (substring s 0 pos) "<->" (substring s (pos + 3) ls)) ]
    member? "->" s  [ let pos position "->" s
                      set rep  (list (substring s 0 pos) "->" (substring s (pos + 2) ls)) ]
    member? "-" s   [ set rep (list "-" (bf s)) ]
    member? "&" s   [ let pos position "&" s
                      set rep  (list (substring s 0 pos) "&" (substring s (pos + 1) ls)) ]
    member? "|" s   [ let pos position "|" s
                      set rep  (list (substring s 0 pos) "|" (substring s (pos + 1) ls)) ])
  report ParseLP:remove-empties rep
end

; Remove empty strings from a list of strings (only in the first level)
; ParseLP:remove-empties ["1" "" "3" "4" ""] == ["1" "3" "4"]
to-report ParseLP:remove-empties [l]
  report filter [el -> not empty? el] l
end

; Replace all substrings s1 of s with s2
; ParseLP:replace-all "aa" "bbaaccaa" "1" == "bb1cc1"
to-report ParseLP:replace-all [s1 s s2]
  ifelse member? s1 s
  [ let pos position s1 s
    set s (word (substring s 0 pos) s2 (substring s (pos + length s1) (length s)))
    report ParseLP:replace-all s1 s s2 ]
  [ report s ]
end

; Transform a string (with brackets) into a string with pieces as strings 
; that can be read
; ParseLP:string-to-list "[123]" = "["123"]"
; ParseLP:string-to-list "[12[34]5]"="["12" ["34"] "5"]"
; ParseLP:string-to-list "12[34]5"= ["12" ["34"] "5"]
to-report ParseLP:string-to-list [s]
  if empty? s [report ""]
  let limits ParseLP:find-limits s
  let i first limits
  let j last limits
  if i = -1 [ report (word "\"" s "\"")]
  report (word
    (ParseLP:string-to-list (substring s 0 i))
    "["
    (ParseLP:string-to-list (substring s (i + 1) j))
    "]"
    (ParseLP:string-to-list (substring s (j + 1) (length s)))
    )
end

; Find the limits of a pair of most external brackets
; ParseLP:find-limits "1[123]4" = [1 5]
to-report ParseLP:find-limits [s]
  let i -1
  let j -1
  let d -1
  foreach (range 0 (length s)) [
    pos ->
    if item pos s = "["
    [ set d d + 1
      if d = 0 [ set i pos ] ]
    if item pos s = "]"
    [ set d d - 1
      if d = -1 [ set j pos ] ]
  ]
  report (list i j)
end

; Remove all spaces from a string
to-report ParseLP:remove-spaces [s]
  report ParseLP:replace-all " " s ""
end

;; Representation as trees
;; The input is a formula as a tree

to parseLP:TreeLayoutAux [l]
  if not empty? l
  [
    let c first l
    (cf:ifelse
      c = "-" [
        hatch-formula-nodes 1 [
          set color yellow
          set shape "not"
          create-formula-link-from myself 
          set depth depth + 1
          parseLP:TreeLayoutAux (last l)
        ]
      ]
      member? c "& | -> <->" [
        hatch-formula-nodes 1 [
          set color yellow
          (cf:ifelse 
            c = "&" [set shape "and"]
            c = "|" [set shape "or"]
            c = "->" [set shape "if"]
            c = "<->" [set shape "iff"])
          create-formula-link-from myself
          set depth depth + 1
          foreach (bf l) [sub -> parseLP:TreeLayoutAux sub]
        ]
      ]
      [ hatch-formula-nodes 1 [
        set color yellow
        set label c
        set shape "square"
        create-formula-link-from myself
        set depth depth + 1]
      ]
    )
  ]
end

to parseLP:TreeLayout [l]
  ca
  ask patches [set pcolor white]
  let f ParseLP:to-tree l
  create-formula-nodes 1 [
    ParseLP:TreeLayoutAux f
    set shape "circle"
    set color yellow
    set size 2
  ]
  ask formula-node 0 [die]
  ask formula-nodes [
    set size 2
    set label-color black
  ]
  set #LayoutNodes formula-nodes
  set #LayoutEdges formula-links
  set #LayoutNode0 formula-node 1
  Layout-space "V"
end

; Return a list of pairs [var n] to identify vars of a formula with 
; natural numbers (negations as negative numbers)
to-report ParseLP:extract-vars [s]
  foreach ["&" "|" "<->" "->" "-" "(" ")"] [
    c -> set s ParseLP:replace-all c s " " ]
  let vp remove-duplicates (ParseLP:split s " ")
  report (map [[v n] -> (list v n)] (sort vp) (range 1 (1 + length vp)))
end
;--------------------------------------------------------------------
; Convert formulas (trees) into CNF
;--------------------------------------------------------------------

; CNF conversion report
; Takes a formula tree and convert it into CNF
to-report ParseLP:cnf [l]
  report
    ParseLP:trDis 
    ParseLP:trNeg 
    ParseLP:tr-> 
    ParseLP:tr<-> l
end

; CNF conversion report
; Takes a formula tree and convert it into CNF
; In contrast with previous version, this one returns literals (-a,-b,...)
to-report ParseLP:cnf2 [l]
  report 
    ParseLP:GrNeg 
    ParseLP:trDis 
    ParseLP:trNeg 
    ParseLP:tr-> 
    ParseLP:tr<-> l
end

; Clause Form conversion from CNF
to-report ParseLP:clause-form [l]
  report ParseLP:flat-list ParseLP:clause-form-aux l
end

; Returns the type of unit of a list: "&", "|", "->", "<->", "-", "vp", false,
to-report ParseLP:unit-type [l]
  (cf:ifelse
    empty? l [ report false ]
    is-string? l [ report "vp" ]
    [ report first l ])
end

; Divides a string s cutting it through "c" ("c"'s are removed)
to-report ParseLP:split [s c]
  ifelse empty? s [report [] ]
  [ let pos position c s
    ifelse pos = false [report (list s)]
    [ report ParseLP:remove-empties fput (substring s 0 pos) (ParseLP:split (substring s (pos + (length c)) (length s)) c) ]
  ]
end

;------------------------------------------------------------------------
;  Standard CNF transformations
;------------------------------------------------------------------------
; Transform <->:
;                (a <-> b) = ((a -> b) & (b -> a))
;
to-report ParseLP:tr<-> [l]
  (cf:ifelse
    empty? l [ report [] ]
    [ let con first l
      (cf:ifelse
        con = "<->" [ let a ParseLP:tr<-> item 1 l
                      let b ParseLP:tr<-> item 2 l
                      report (list "&" (list "->" a b) (list "->" b a)) ]
        con = "-"   [ let a ParseLP:tr<-> item 1 l
                      report (list con a) ]
        con = "&" or con ="|" or con = "->" [ let a ParseLP:tr<-> item 1 l
                                              let b ParseLP:tr<-> item 2 l
                                              report (list con a b) ]
        [ report l ] )])
end

; Transform -> :
;                (a -> b) = (-a | b)
;
to-report ParseLP:tr-> [l]
  ifelse empty? l
  [ report [] ]
  [ let con first l
    (cf:ifelse
      con = "->" [ let a ParseLP:tr-> item 1 l
                   let b ParseLP:tr-> item 2 l
                   report (list "|" (list "-" a) b) ]
      con = "-"  [ let a ParseLP:tr-> item 1 l
                   report (list con a) ]
      con = "&" or con ="|" [ let a ParseLP:tr-> item 1 l
                              let b ParseLP:tr-> item 2 l
                              report (list con a b) ]
      [ report l ])]
end

; Transforma -:
;              (-(-a)) = a
;              (-(a & b)) = ((-a) | (-b))
;              (-(a | b)) = ((-a) & (-b))
;
to-report ParseLP:trNeg [l]
  ifelse empty? l
  [ report [] ]
  [ let con first l
    (cf:ifelse
      con = "-" [ let a item 1 l
                  let con_a first a
                  (cf:ifelse
                    not member? con_a "- & |" [ report l ]
                    con_a = "-" [ report ParseLP:trNeg (last a) ]
                    [ let a1 item 1 a
                      let b1 item 2 a
                      (cf:ifelse
                        con_a = "&" [ report (list "|" (ParseLP:trNeg (list "-" a1)) (ParseLP:trNeg (list "-" ParseLP:trNeg b1))) ]
                        con_a = "|" [ report (list "&" (ParseLP:trNeg (list "-" a1)) (ParseLP:trNeg (list "-" ParseLP:trNeg b1))) ]
                        [ report l ])])]
      con = "&" or con = "|" [ let a item 1 l
                               let b item 2 l
                               report (list con (ParseLP:trNeg a) (ParseLP:trNeg b)) ]
      [ report l ])]
end

; Distributive Transformation:
;              (a|(b&c)) = ((a|b)&(a|c))
;              ((a&b)|c) = ((a|c)&(b|c))
; In prefix notation:
;              [| a [& a1 b1]] = [& [| a a1] [| a b1]]
;              [| [& a1 b1] b] = [& [| a1 b] [| b1 b]]
;
; It makes use of an auxiliar report because we have to appply it an unknown number of times,
; until an application does not produce changes. The application in a level can produce the
; necessity of a new appplication in an upper level

to-report ParseLP:trDis [l]
  let rep ParseLP:trDisAux l
  ifelse rep = l
  [report l]
  [report ParseLP:trDis rep]
end

to-report ParseLP:trDisAux [l]
  ifelse empty? l
  [ report [] ]
  [ let con first l
    (cf:ifelse
      con = "|" [ let a item 1 l
                  let b item 2 l
                  (cf:ifelse
                    first a = "&" [ let a1 ParseLP:trDisAux item 1 a
                                    let b1 ParseLP:trDisAux item 2 a
                                    report (list "&" (list "|" a1 (ParseLP:trDisAux b)) (list "|" b1 (ParseLP:trDisAux b))) ]
                    first b = "&" [ let a1 ParseLP:trDisAux item 1 b
                                    let b1 ParseLP:trDisAux item 2 b
                                    report (list "&" (list "|" (ParseLP:trDisAux a) a1) (list "|" (ParseLP:trDisAux a) b1)) ]
                    [ report (list "|" (ParseLP:trDisAux a) (ParseLP:trDisAux b)) ])]
      con = "&" [ let a item 1 l
                  let b item 2 l
                  report (list "&" (ParseLP:trDisAux a) (ParseLP:trDisAux b)) ]
      con = "-" [ let a item 1 l
                  report (list "-" (ParseLP:trDisAux a)) ]
      [ report l ])]
end

; Change ["-" "a"] = "-a" (requires l in CNF)
to-report ParseLP:GrNeg [l]
  ifelse empty? l
  [ report l ]
  [ ifelse is-list? l
    [ let con first l
      ifelse con = "-"
      [ report (word "-" (last l)) ]
      [ let a item 1 l
        let b item 2 l
        report (list con (ParseLP:GrNeg a) (ParseLP:GrNeg b)) ]
    ]
    [ report l ]
  ]
end

; Extract Clausal Form (requires l in CNF)
to-report ParseLP:clause-form-aux [l]
  ifelse empty? l [report [] ]
  [
    (cf:ifelse
      ParseLP:unit-type l = "vp" [ report (list l) ]
      ParseLP:unit-type l = "&"  [ let a item 1 l
                           let b item 2 l
                           report list (ParseLP:clause-form-aux a) (ParseLP:clause-form-aux b)]
      ParseLP:unit-type l = "|"  [ report  ParseLP:process-disjunct l])
  ]
end

; Process all the levels in a disjunction to join them in one single list (requires l in CNF)
to-report ParseLP:process-disjunct [l]
  let rep ParseLP:flat l
  set rep remove "|" rep
  report rep
end

; Cleaning Clauses (requires Clause Form with neg)
to-report ParseLP:CleanCF [l]
  report filter [c -> not empty? c] map ParseLP:CleanClause l
end

to-report ParseLP:CleanClause [c]
  set c remove-duplicates c
  let contra? reduce or map [lit -> member? (ParseLP:neg lit) c] c
  ifelse contra?
  [ report [] ]
  [ report c ]
end

; Flatten a list with several levels (its elements mus be strings)
; flat ["1" "2" ["3" "4" ["5"]]] = ["1" "2" "3" "4" "5"]
to-report ParseLP:flat [l]
  (cf:ifelse
    is-string? l [ report l ]
    empty? l     [ report [] ]
    [ report sentence (ParseLP:flat (first l)) (ParseLP:flat (bf l))])
end

; Flatten a lis of lists, leaving the one-level lists as basic units
; flat-list [["1" "2"] [["3" "4"] ["5"]]] = [["1" "2"] ["3" "4"] ["5"]]
to-report ParseLP:flat-list [l]
  if is-list? l and (reduce and map is-string? l) [report l]
  let rep []
  foreach l [
    c ->
    ifelse is-list? c and (reduce and map is-string? c)
    [ set rep lput c rep ]
    [ set rep sentence rep (ParseLP:flat-list c) ]
  ]
  report rep
end

; Replace numerical vars ("1", "2",...) with their values (1,2,...)
; Requires a Clause Form
to-report ParseLP:numberize [l]
  report map [c -> map read-from-string c] l
end

; Auxiliary prodecure to negate a literal
to-report ParseLP:neg [u]
  ifelse (first u) = "-" 
  [report bf u]
  [report (word "-" u)]
end
