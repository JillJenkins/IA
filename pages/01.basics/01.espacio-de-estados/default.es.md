---
title: 'Espacio de Estados'
taxonomy:
    category:
        - docs
visible: true
---

<p>&lt;div style="text-align: justify;"&gt;<br />&lt;div&gt;[[image file="2015-07/c6f563de-154e-11e2-bb76-001e670c2818.jpg" align="left" ]]Sin lugar a dudas, una de las principales caracter&amp;iacute;sticas que reconocemos en la inteligencia es la capacidad para resolver problemas. Si consideramos una inteligencia como la humana, a la habilidad para analizar los elementos intr&amp;iacute;nsecos de cada problema, que est&amp;aacute; presente tambi&amp;eacute;n en muchas otras especies animales, se a&amp;ntilde;ade la &lt;strong&gt;capacidad de abstraerlos e&amp;nbsp;identiﬁcar las acciones que se pueden realizar&lt;/strong&gt; sobre ellos para resolver el problema. En un nivel incluso superior de abstracci&amp;oacute;n, reconocible solo en las llamadas especies superiores, podemos considerar tambi&amp;eacute;n la capacidad de determinar cu&amp;aacute;l puede ser, de entre los posibles m&amp;eacute;todos que se idean, el m&amp;aacute;s adecuado, ya sea en t&amp;eacute;rminos de tiempo, de recursos, de seguridad para el individuo, etc. De esta forma, aparece una triple capacidad de &lt;strong&gt;an&amp;aacute;lisis&lt;/strong&gt;, &lt;strong&gt;abstraccci&amp;oacute;n&lt;/strong&gt; y &lt;strong&gt;estrategia&lt;/strong&gt;&amp;nbsp;que &lt;span&gt;sit&amp;uacute;a el tema general de la resoluci&amp;oacute;n de problemas en el n&amp;uacute;cleo de la inteligencia artiﬁcial y, p&lt;/span&gt;or ello, no resulta extra&amp;ntilde;o que se consideren deseables para cualquier individuo, artificial o no, que queramos que se comporte inteligentemente.&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;Podemos pensar en una variedad de problemas que van desde c&amp;oacute;mo alcanzar una fuente de comida situada a cierta distancia y a la que no se puede ir directamente, hasta c&amp;oacute;mo resolver un peque&amp;ntilde;o juego como podr&amp;iacute;a ser el famoso cubo de Rubik, o resolver el problema matem&amp;aacute;tico de encontrar la soluci&amp;oacute;n a una ecuaci&amp;oacute;n num&amp;eacute;rica. En todos ellos encontramos elementos comunes tras un proceso de abstracci&amp;oacute;n que nos permiten de forma general deﬁnir la &lt;strong&gt;resoluci&amp;oacute;n de problemas&lt;/strong&gt; como:&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;blockquote&gt;<br />&lt;div style="padding-left: 60px;"&gt;&lt;em&gt;el proceso que, partiendo de una situaci&amp;oacute;n inicial y utilizando un conjunto de procedimientos/reglas/acciones seleccionados a priori, es capaz de explicitar el conjunto de&amp;nbsp;pasos que nos llevan a una situaci&amp;oacute;n posterior que llamamos &lt;strong&gt;soluci&amp;oacute;n&lt;/strong&gt;&lt;/em&gt;.&lt;/div&gt;<br />&lt;/blockquote&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;Lo que consideremos o no soluci&amp;oacute;n depender&amp;aacute; del contexto concreto del problema, y puede ser, por&amp;nbsp;ejemplo, el conjunto de acciones que nos llevan a cumplir cierta propiedad, conseguir cierto objetivo, o verificar ciertas restricciones.&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;Como estamos interesados en la generaci&amp;oacute;n de mecanismos autom&amp;aacute;ticos que se puedan llamar inteligentes, no nos contentamos con resolver problemas individuales y dar para cada problema una soluci&amp;oacute;n independiente, sino que intentaremos buscar elementos&amp;nbsp;comunes a una gran bolsa de problemas que faciliten dar una clasificaci&amp;oacute;n de los mismos y reconocer m&amp;eacute;todos y estrategias que puedan ser v&amp;aacute;lidos de la forma m&amp;aacute;s general posible.&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;Para ello, y teniendo en cuenta lo la idea de &lt;strong&gt;modelar&lt;/strong&gt;, es necesario&amp;nbsp;que podamos expresar las caracter&amp;iacute;sticas de los problemas usando un lenguaje formal com&amp;uacute;n a todos ellos, para posteriormente proporcionar m&amp;eacute;todos y estrategias generales (en forma de algoritmos o de heur&amp;iacute;sticas, en nuestro caso) con los que poder obtener &lt;span&gt;con ciertas garant&amp;iacute;as &lt;/span&gt;soluciones de esos problemas.&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;&lt;span&gt;[[image file="2017-09/kr-entc.gif" ]]&lt;/span&gt;&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;<br />&lt;div&gt;Una de las aproximaciones m&amp;aacute;s generales y sencillas de formalizar un problema y sus posibles mecanismos de soluci&amp;oacute;n es por medio de lo que se denomina&amp;nbsp;&lt;strong&gt;espacio de estados&lt;/strong&gt;. Antes de definir formalmente en qu&amp;eacute; consiste este espacio, observemos que en todo momento estamos tratando con m&amp;eacute;todos en los que la resoluci&amp;oacute;n de los problemas se dan de forma din&amp;aacute;mica, es decir, se supone que se produce una evoluci&amp;oacute;n temporal, que pasa por etapas, que nos permite llegar de la situaci&amp;oacute;n inicial en la que el problema se presenta hasta una situaci&amp;oacute;n final en la que se ha encontrado la soluci&amp;oacute;n del mismo. Es precisamente esta din&amp;aacute;mica, en la que aplicamos las reglas u operaciones de las que disponemos, la que permite ir modificando cada situaci&amp;oacute;n posible para llevarnos desde el inicio a la soluci&amp;oacute;n. Simplemente, denominaremos &lt;strong&gt;estado&lt;/strong&gt; a la &lt;em&gt;representaci&amp;oacute;n de los elementos que describen el problema en un momento dado&lt;/em&gt;, es decir, a la situaci&amp;oacute;n en que se encuentra o se podr&amp;iacute;a encontrar el problema en cada instante de tiempo.&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;blockquote&gt;<br />&lt;div style="padding-left: 60px;"&gt;&lt;strong&gt;Estado&lt;/strong&gt;:&amp;nbsp;&lt;em&gt;representaci&amp;oacute;n de los elementos que describen el problema en un momento dado.&lt;/em&gt;&lt;/div&gt;<br />&lt;/blockquote&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;La cuesti&amp;oacute;n principal que debemos plantearnos para esta metodolog&amp;iacute;a es acerca de qu&amp;eacute; debemos incluir en el estado. Por desgracia, no existen directrices generales que permitan dar una respuesta satisfactoria a esta cuesti&amp;oacute;n pero, siguiendo t&amp;eacute;cnicas de resoluci&amp;oacute;n de problemas cl&amp;aacute;sicas, podemos asegurar que es importante guardar un equlibrio entre el ahorro de recursos de almacenamiento para la descripci&amp;oacute;n del estado y la necesidad de tener suficiente informaci&amp;oacute;n almacenada como para poder resolver el problema. Aunque a priori puede parecer una buena idea almacenar toda la informaci&amp;oacute;n posible, pronto veremos que en problemas relativamente peque&amp;ntilde;os la cantidad de estados puede ser tan grande que la capacidad de almacenamiento computacional se nos puede agotar sin darnos la opci&amp;oacute;n de resolver el problema. Vemos, pues, que este enfoque entronca directamente con teor&amp;iacute;as matem&amp;aacute;ticas bien establecidas, como son la &lt;strong&gt;Teor&amp;iacute;a de la Computabilidad&lt;/strong&gt; (que estudia qu&amp;eacute; es resoluble de forma autom&amp;aacute;tica) y la &lt;strong&gt;Teor&amp;iacute;a de la Complejidad&lt;/strong&gt; (que estudia cu&amp;aacute;ntos recursos necesitamos para resolver los problemas que s&amp;iacute; son resolubles).&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;blockquote&gt;<br />&lt;div style="padding-left: 60px;"&gt;Debe existir un equilibrio entre&amp;nbsp;&lt;span&gt;el ahorro de recursos de almacenamiento para la descripci&amp;oacute;n del estado y la necesidad de tener suficiente informaci&amp;oacute;n almacenada como para poder resolver el problema&lt;/span&gt;&lt;/div&gt;<br />&lt;/blockquote&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;&lt;span&gt;Este proceso de elegir adecuadamente la informaci&amp;oacute;n que almacenamos en un estado es tan importante que se ha convertido en un eje central de la Inteligencia Artificial, recibiendo el nombre de &lt;a href="http://www.cs.us.es/~fsancho/?e=172" target="_blank"&gt;&lt;strong&gt;Teor&amp;iacute;a de la Representaci&amp;oacute;n&lt;/strong&gt;&lt;/a&gt;, y ha demostrado ser esencial para que algoritmos y heur&amp;iacute;sticas concretas de resoluci&amp;oacute;n sean o no eficientes a la hora de resolver problemas. Un buen algoritmo con una mala representaci&amp;oacute;n puede ser tan ineficiente como un mal algoritmo y, muchas veces, una buena representaci&amp;oacute;n es capaz de llevarnos a una soluci&amp;oacute;n del problema incluso usando algoritmos malos. &lt;/span&gt;&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;&lt;span&gt;&lt;strong&gt;La elecci&amp;oacute;n de los estados&lt;/strong&gt;, como veremos m&amp;aacute;s adelante en casos concretos, &lt;strong&gt;no solo determina qu&amp;eacute; informaci&amp;oacute;n se almacenar&amp;aacute; de las diversas situaciones por las que pasa el problema, sino que en muchos casos es determinante tambi&amp;eacute;n para decidir cu&amp;aacute;les son las reglas u operaciones b&amp;aacute;sicas que se permiten para realizar transformaciones entre estados&lt;/strong&gt;. Otras veces tambi&amp;eacute;n podemos encontrar restricciones debido a la incapacidad para realizar ciertas acciones para resolver un problema, lo que puede influir en c&amp;oacute;mo se elegir&amp;aacute;n los estados para hacerlos coherentes con las operaciones disponibles. En general, e&lt;/span&gt;l proceso de transformar el problema original (al que muchas veces llamaremos simplemente "mundo real") en este espacio de estados que es manipulable por medios autom&amp;aacute;ticos es lo que conocemos como &lt;strong&gt;modelar el problema&lt;/strong&gt;&amp;nbsp;(debe tenerse en cuenta que el modelado existe en otras muchas ramas de la ciencia, y nosotros aqu&amp;iacute; solo consideramos el modelado computacional, que es un tipo particular de modelado matem&amp;aacute;tico).&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;blockquote&gt;<br />&lt;div&gt;Modelar computacional de un problema: proceso de transformar el problema original ("mundo real") en un espacio de estados que es manipulable por medios autom&amp;aacute;ticos.&lt;/div&gt;<br />&lt;/blockquote&gt;<br />&lt;/div&gt;<br />&lt;/div&gt;<br />&lt;h2 style="text-align: justify;"&gt;Problema de b&amp;uacute;squeda b&amp;aacute;sico&lt;/h2&gt;<br />&lt;div style="text-align: justify;"&gt;[[image file="2016-11/GraphStateSpace.png" align="right" width=300px ]]Si nos imaginamos este espacio de estados como un terreno por el cual nos podemos mover, donde partimos de un punto concreto del terreno (&lt;strong&gt;estado inicial&lt;/strong&gt;) y podemos aplicar las reglas v&amp;aacute;lidas para ir saltando de un estado a otro, podemos identificar la resoluci&amp;oacute;n del problema (llegar hasta un &lt;strong&gt;estado final&lt;/strong&gt; v&amp;aacute;lido) con el problema de &lt;strong&gt;buscar un camino&lt;/strong&gt; adecuado entre un estado inicial y un estado final. Es por ello que muy habitualmente se habla del &lt;strong&gt;Problema de B&amp;uacute;squeda en el Espacio de Estados&lt;/strong&gt;.&amp;nbsp;Pasemos pues a dar una definici&amp;oacute;n formal de esta idea:&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;Un &lt;strong&gt;problema de b&amp;uacute;queda b&amp;aacute;sico&lt;/strong&gt; es una 4-tupla \((X,S,G,d)\), donde&amp;nbsp;&lt;/div&gt;<br />&lt;ul&gt;<br />&lt;li style="text-align: justify;"&gt;\(X\) es un &lt;strong&gt;conjunto de estados&lt;/strong&gt; (el que hemos estado llamando &lt;strong&gt;Espacio de Estados&lt;/strong&gt;).&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;\(S \subseteq X\), es un conjunto no vac&amp;iacute;o de &lt;strong&gt;estados iniciales&lt;/strong&gt;&amp;nbsp;(no tiene porqu&amp;eacute; existir un solo estado de partida).&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;\(G \subseteq X\), es un conjunto no vac&amp;iacute;o de &lt;strong&gt;estados finales&lt;/strong&gt;&amp;nbsp;(\(G\) se usa como inicial de Goals, objetivos en ingl&amp;eacute;s, y al igual que no existe un &amp;uacute;nico estado de partida, puede ocurrir que haya muchos estados finales v&amp;aacute;lidos para el mismo problema).&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;\(d: X \rightarrow \cal{P}(X)\) es una &lt;strong&gt;funci&amp;oacute;n de transici&amp;oacute;n&lt;/strong&gt;. Para cada \(x\in X\), \(d(x)\) determina el conjunto de estados sucesores de \(x\) (\(\cal{P}(X)\) representa las partes de \(X\), es decir, el conjunto de los posibles subconjuntos de \(X\), ya que desde un estado concreto podemos llegar a varios posibles estados aplicando distintas operaciones o reglas permitidas).&lt;/li&gt;<br />&lt;/ul&gt;<br />&lt;p&gt;Observa que esta definici&amp;oacute;n formal no explicita ni la forma en que hay que almacenar la informaci&amp;oacute;n en los estados ni cu&amp;aacute;les son las reglas v&amp;aacute;lidas que permiten pasar de un estado a otro durante la resoluci&amp;oacute;n, ya que todo ello depende del problema concreto que se est&amp;eacute; resolviendo y nosotros estamos interesados en dar un marco general que permita aplicar los m&amp;eacute;todos que desarrollemos al mayor conjunto posible de problemas.&amp;nbsp;&lt;/p&gt;<br />&lt;p&gt;Una vez fijado este primer marco de representaci&amp;oacute;n, podemos dar los pasos generales necesarios para "buscar" el camino que lleve desde el planteamiento inicial del problema hasta una soluci&amp;oacute;n:&lt;/p&gt;<br />&lt;ol&gt;<br />&lt;li style="text-align: justify;"&gt;&lt;strong&gt;Dar una representaci&amp;oacute;n del problema&lt;/strong&gt;, es decir, definir un &lt;strong&gt;espacio de estados&lt;/strong&gt;&amp;nbsp;que refleje las caracter&amp;iacute;sticas del mundo real que sean necesarias para la resoluci&amp;oacute;n del problema. Como ya se ha indicado, ha de tenerse en cuenta que esta elecci&amp;oacute;n no es &amp;uacute;nica, y que determinar&amp;aacute; en gran medida la facilidad o dificultad de resolver el problema que tenemos entre manos. Asimismo, este paso determina tambi&amp;eacute;n las acciones disponibles para moverse por este espacio. La capacidad para cambiar de representaci&amp;oacute;n para obtener una m&amp;aacute;s adecuada a la soluci&amp;oacute;n del problema es lo que se denomina &lt;strong&gt;perspicacia&lt;/strong&gt;.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;Especificar uno, o m&amp;aacute;s, &lt;strong&gt;estados iniciales&lt;/strong&gt;.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;Especificar uno, o m&amp;aacute;s &lt;strong&gt;estados finales&lt;/strong&gt; (objetivos o metas). A veces no se especifican propiamente los estados finales, sino alguna propiedad que han de cumplir para que se consideren v&amp;aacute;lidos.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;Definir &lt;strong&gt;reglas&lt;/strong&gt;&amp;nbsp;a partir de las acciones disponibles. El conjunto de reglas definir&amp;aacute; la funci&amp;oacute;n de transici&amp;oacute;n del sistema formal. Estas reglas determinan la estructura del espacio de estados, y esta estructura es responsable, en gran medida de la dificultad que nos encontremos posteriormente para realizar b&amp;uacute;squedas en el espacio.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;El problema se resuelve &lt;strong&gt;usando las reglas en combinaci&amp;oacute;n con una estrategia de control&lt;/strong&gt;. De nuevo, obs&amp;eacute;rvese que aqu&amp;iacute; no prefijamos ninguna estrategia de control espec&amp;iacute;fica. M&amp;aacute;s adelante veremos algunas de las m&amp;aacute;s habituales y estudiaremos sus bondades e inconvenientes para resolver problemas de forma general. Una buena estrategia de control debe establecer el &lt;strong&gt;orden de aplicaci&amp;oacute;n de las reglas&lt;/strong&gt; y &lt;strong&gt;resuelve los posibles conflictos&lt;/strong&gt; que puedan aparecer.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;Dependiendo de la estrategia de control utilizada, o de las necesidades de la b&amp;uacute;squeda, puede ser necesaria una &lt;strong&gt;funci&amp;oacute;n de coste&lt;/strong&gt; que indique cu&amp;aacute;nto cuesta aplicar una regla determinada a un estado determinado, de esa forma podemos calcular cu&amp;aacute;nto cuesta el proceso total de ir desde un estado inicial hasta un estado final aplicando dicha estrategia, y de esta forma comparar entre s&amp;iacute; los distintos caminos que existen para resolver el problema.&lt;/li&gt;<br />&lt;/ol&gt;<br />&lt;h3 style="text-align: justify;"&gt;Ejemplo&lt;/h3&gt;<br />&lt;div style="text-align: justify;"&gt;Como primer ejemplo, consideremos el &lt;strong&gt;puzle de piezas deslizantes&lt;/strong&gt;, donde el objetivo es deslizar las piezas usando el hueco hasta conseguir el orden deseado. El caso general consiste en un puzzle de \(n\times m\) cuadr&amp;iacute;culas, con \(n\times m-1\) piezas numeradas consecutivamente y 1 hueco. A veces podemos encontrar este puzle en una variante equivalente haciendo uso de im&amp;aacute;genes que han de reconstruirse situando el orden adecuado en sus piezas.&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: center;"&gt;[[image file="2015-07/a1c910b4-1527-11e2-bb76-001e670c2818.jpg" ]]&lt;/div&gt;<br />&lt;div style="text-align: center;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;El espacio de estados, \(X\), describe todas las posibles combinaciones de las piezas y el hueco. Como queremos dar un m&amp;eacute;todo general de resoluci&amp;oacute;n, el conjunto de los estados iniciales es, en este caso, todo el espacio \(S=X\), y el conjunto de estados finales es &amp;uacute;nicamente uno, el estado en el que todos est&amp;aacute;n en orden y el hueco se sit&amp;uacute;a al final, tal y como muestra la figura anterior. La funci&amp;oacute;n de transici&amp;oacute;n describe el cambio que resulta de mover, en un estado concreto, el hueco en cualquiera de las 4 direcciones (en los bordes y esquinas s&amp;oacute;lo podr&amp;aacute; moverse en 3 o 2 direcciones posibles, respectivamente).&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;Obs&amp;eacute;rvese que, en este caso, la soluci&amp;oacute;n al puzzle no es el estado final, que sabemos ex&amp;aacute;ctamente cu&amp;aacute;l es, sino el camino que lleva desde un estado inicial (prefijado, o aleatorio) hasta ese estado final. Es decir, deseamos conocer la sucesi&amp;oacute;n de movimientos que nos permiten resolver el puzle.&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: center;"&gt;[[image file="2015-07/23717796-1528-11e2-bb76-001e670c2818.jpg" ]]&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;En el caso de un puzle de tama&amp;ntilde;o \(3\times 3\) (e&lt;span&gt;n este caso el puzle se conoce como&amp;nbsp;&lt;/span&gt;&lt;strong&gt;8-puzle&lt;/strong&gt;, que es el n&amp;uacute;mero de piezas m&amp;oacute;viles&lt;span&gt;)&amp;nbsp;&lt;/span&gt;el n&amp;uacute;mero de posibles estados es de \(9!= 362880\), un tama&amp;ntilde;o que permite, con la capacidad de los ordenadores actuales, hacer una b&amp;uacute;squeda exahustiva para encontrar el camino desde cualquier estado al estado final ordenado. Esta b&amp;uacute;squeda exahustiva se consigue comenzando por el estado inicial e ir visitando a partir de &amp;eacute;l todos los dem&amp;aacute;s estados por la aplicaci&amp;oacute;n sucesiva de las reglas de transici&amp;oacute;n, de esta forma, si existe una soluci&amp;oacute;n (un camino que conecta el estado inicial y el final) este m&amp;eacute;todo la encontrar&amp;aacute;, aunque, posiblemente, de una forma completamente ineficiente.&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;<br />&lt;div&gt;Si jugamos con el puzle de tama&amp;ntilde;o \(4\times 4\) (que se conoce como &lt;strong&gt;15-puzle&lt;/strong&gt;) el n&amp;uacute;mero de posibles estados es de \(16! \approx 2x10^{13}\), demasiado grande para una b&amp;uacute;squeda exahustiva. En casos como &amp;eacute;ste, donde el espacio de estados es excesivamente grande para hacer un recorrido exahustivo de sus elementos, hemos de encontrar estrategias de b&amp;uacute;squeda m&amp;aacute;s depuradas que nos permitan alcanzar las soluciones de forma m&amp;aacute;s eficiente y usando menos recursos (en tiempo y en espacio almacenado).&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;Consideremos otro puzle habitual, &lt;strong&gt;el puzle de los misioneros y can&amp;iacute;bales&lt;/strong&gt;: Tres misioneros se perdieron explorando una jungla. Separados de sus compa&amp;ntilde;eros, sin alimento y sin radio, s&amp;oacute;lo sab&amp;iacute;an que para llegar a su destino deb&amp;iacute;an ir siempre hacia adelante. Los tres misioneros se detuvieron frente a un r&amp;iacute;o que les bloqueaba el paso, pregunt&amp;aacute;ndose que pod&amp;iacute;an hacer. De repente, aparecieron tres can&amp;iacute;bales llevando un bote, pues tambi&amp;eacute;n ellos quer&amp;iacute;an cruzar el r&amp;iacute;o. Ya anteriormente se hab&amp;iacute;an encontrado grupos de misioneros y can&amp;iacute;bales, y cada uno respetaba a los otros, pero sin confiar entre ellos. Los can&amp;iacute;bales se com&amp;iacute;an a los misioneros cuando les superaban en n&amp;uacute;mero, y los misioneros bautizaban a los can&amp;iacute;bales en situaciones similares. Todos quer&amp;iacute;an cruzar el r&amp;iacute;o, pero el bote no pod&amp;iacute;a llevar m&amp;aacute;s de dos personas a la vez y los misioneros no quer&amp;iacute;an que los can&amp;iacute;bales les aventajaran en n&amp;uacute;mero. &amp;iquest;C&amp;oacute;mo puede resolverse el problema, sin que en ning&amp;uacute;n momento hayan m&amp;aacute;s can&amp;iacute;bales que misioneros en cualquier orilla del r&amp;iacute;o?&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;El espacio de estados asociado al problema podr&amp;iacute;a representarse de la siguiente forma (muy descriptiva, pero poco pr&amp;aacute;ctica desde el punto de vista computacional):&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div&gt;&lt;span&gt;[[image file="2017-09/mc-search-space.png" ]]&lt;/span&gt;&lt;/div&gt;<br />&lt;div&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&lt;cite&gt;&lt;strong&gt;Ejercicio&lt;/strong&gt;: Formaliza la siguiente versi&amp;oacute;n del puzle "&lt;em&gt;Todos los d&amp;iacute;gitos del Rey&lt;/em&gt;" explicitando una representaci&amp;oacute;n de sus estados y la funci&amp;oacute;n de transici&amp;oacute;n entre ellos: Dado el conjunto de d&amp;iacute;gitos \(0123456789\), inserta los s&amp;iacute;mbolos de los operadores aritm&amp;eacute;ticos (\(\times + - /,\)) entre ellos para que la expresi&amp;oacute;n resultante se eval&amp;uacute;e como 100. Por ejemplo:&lt;/cite&gt;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&lt;cite&gt;\[0+1+2+3+4+5+6+7+(8\times 9) =100\]&lt;/cite&gt;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&lt;cite&gt;&amp;iquest;Puedes encontrar otros?&lt;/cite&gt;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;h2 style="text-align: justify;"&gt;Criterios de evaluaci&amp;oacute;n&lt;/h2&gt;<br />&lt;div style="text-align: justify;"&gt;Antes de que pasemos a ver la variedad de algoritmos (estrategias) que han sido dise&amp;ntilde;ados para resolver problemas de b&amp;uacute;squeda en espacios de estados, puede merecer la pena mencionar, aunque sea de forma breve, c&amp;oacute;mo podemos evaluar la eficiencia de estos algoritmos. Habitualmente, se suelen usar los siguientes criterios de evaluaci&amp;oacute;n:&amp;nbsp;&lt;/div&gt;<br />&lt;ul&gt;<br />&lt;li style="text-align: justify;"&gt;&lt;strong&gt;Complejidad en tiempo&lt;/strong&gt;: Se puede medir como el n&amp;uacute;mero de veces que se aplica la funci&amp;oacute;n de transici&amp;oacute;n que necesita el algoritmo para encontrar la soluci&amp;oacute;n. En un contexto m&amp;aacute;s amplio suele medirse por medio del n&amp;uacute;mero de pasos que da un algoritmo en su ejecuci&amp;oacute;n.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;&lt;strong&gt;Complejidad en espacio&lt;/strong&gt;: Se mide por la cantidad de espacio de almacenamiento necesario para encontrar la soluci&amp;oacute;n. En el caso que estamos viendo lo podemos medir como el n&amp;uacute;mero de estados que el algoritmo debe mantener en memoria para encontrar la soluci&amp;oacute;n. Algunos algoritmos podr&amp;aacute;n "olvidar" los estados por los que van pasando, mientras que otros necesitan mantener una memoria con esos estados para poder volver atr&amp;aacute;s en la b&amp;uacute;squeda o saber por cu&amp;aacute;les ha pasado.&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;&lt;strong&gt;Completitud&lt;/strong&gt;: Si existe una soluci&amp;oacute;n, &amp;iquest;est&amp;aacute; garantizado por el algoritmo que la encontraremos?&lt;/li&gt;<br />&lt;li style="text-align: justify;"&gt;&lt;strong&gt;Optimalidad&lt;/strong&gt;: Si existen varias soluciones, &amp;iquest;encuentra el algoritmo la &amp;oacute;ptima? Esta optimalidad se mide respecto de alguna medida, por ejemplo, la que est&amp;aacute; m&amp;aacute;s cerca en n&amp;uacute;mero de transformaciones para llegar desde el estado inicial, o la que ha usado menos memoria.&lt;/li&gt;<br />&lt;/ul&gt;<br />&lt;h2 style="text-align: justify;"&gt;Una representaci&amp;oacute;n (casi) universal&lt;/h2&gt;<br />&lt;div style="text-align: justify;"&gt;Normalmente, los algoritmos que vamos a ver se basan en la suposici&amp;oacute;n de que el espacio de b&amp;uacute;squeda tiene la estructura de un grafo dirigido: cada &lt;strong&gt;nodo&lt;/strong&gt; del grafo representa uno de los estados del espacio, y dos nodos est&amp;aacute;n conectados si existe una forma de ir de uno al otro por medio de la funci&amp;oacute;n de transici&amp;oacute;n.&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;Normalmente, cuando resolvemos el problema a partir de un estado particular, podemos construir un &amp;aacute;rbol que se construye partiendo del estado inicial y donde en cada nivel se a&amp;ntilde;aden los estados que se pueden alcanzar desde los estados del nivel anterior (y que, en consecuencia, puede contener estados repetidos). En este caso, la &lt;strong&gt;profundidad&lt;/strong&gt;&amp;nbsp;(\(d\), de &lt;strong&gt;depth&lt;/strong&gt;) del &amp;aacute;rbol es la longitud m&amp;aacute;xima de los caminos que se pueden construir desde cualquier nodo a la ra&amp;iacute;z; y el &lt;strong&gt;factor de ramificaci&amp;oacute;n&lt;/strong&gt;&amp;nbsp;(\(b\), de &lt;strong&gt;branch&lt;/strong&gt;) del &amp;aacute;rbol es el m&amp;aacute;ximo n&amp;uacute;mero de sucesores que puede tener un nodo del &amp;aacute;rbol.&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;En un &amp;aacute;rbol, los sucesores inmediatos de un nodo (salvo las hojas, claro, que son los nodos terminales) se llaman &lt;strong&gt;hijos&lt;/strong&gt;, el predecesor de un nodo (salvo la ra&amp;iacute;z, que no tiene predecesor), que es &amp;uacute;nico, se llama &lt;strong&gt;padre&lt;/strong&gt;, y los nodos que tienen el padre com&amp;uacute;n se llaman &lt;strong&gt;hermanos&lt;/strong&gt;.&lt;/div&gt;<br />&lt;div style="text-align: center;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: center;"&gt;[[image file="2015-07/96a74992-1529-11e2-bb76-001e670c2818.png" ]]&lt;/div&gt;<br />&lt;div style="text-align: center;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;Es importante destacar que nuestro espacio de estados &lt;strong&gt;NO&lt;/strong&gt; es un &amp;aacute;rbol, sino que el &amp;aacute;rbol se consigue al considerar la estructura ordenada que surge entre los diversos estados de nuestro problema al aplicar las reglas que permiten pasar de unos estados a otros. Si cambiamos la representaci&amp;oacute;n de los estados (y en consecuencia las reglas que se pueden aplicar) cambiar&amp;aacute; el &amp;aacute;rbol asociado, pero nuestro problema sigue siendo el mismo. Es por ello que la representaci&amp;oacute;n es fundamental para obtener soluciones m&amp;aacute;s o menos eficientes, ya que los posibles caminos entre los nodos que representan estados iniciales y los nodos que representan estados finales pueden cambiar completamente dependiendo del &amp;aacute;rbol que obtengamos.&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&amp;nbsp;&lt;/div&gt;<br />&lt;h2 style="text-align: justify;"&gt;Para saber m&amp;aacute;s...&lt;/h2&gt;<br />&lt;div style="text-align: justify;"&gt;[[popup description="&lt;span&gt;Tema 3 de la asignatura de IA del Grado en Ingenier&amp;iacute;a en Inform&amp;aacute;tica - Tecnolog&amp;iacute;as Inform&amp;aacute;ticas&lt;/span&gt;" title="&lt;span&gt;Tema 3 de la asignatura de IA del Grado en Ingenier&amp;iacute;a en Inform&amp;aacute;tica - Tecnolog&amp;iacute;as Inform&amp;aacute;ticas&lt;/span&gt;" fb_type="iframe" url="http://www.cs.us.es/cursos/iati/temas/tema-03.pdf"]]&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&lt;span&gt;[[popup description="&lt;/span&gt;&lt;span&gt;Tema 3 Artificial Intellicenge and its teaching&lt;/span&gt;&lt;span&gt;" title="&lt;span&gt;Tema 3 Artificial Intellicenge and its teaching&lt;/span&gt;&lt;/span&gt;&lt;span&gt;" fb_type="iframe" url="&lt;span&gt;http://aries.ektf.hu/~gkusper/ArtificialIntelligence_LectureNotes.v.1.0.4.pdf&lt;/span&gt;&lt;/span&gt;&lt;span&gt;"]]&lt;/span&gt;&lt;/div&gt;<br />&lt;div style="text-align: justify;"&gt;&lt;span&gt;[[popup description="&lt;/span&gt;&lt;span&gt;Tema 3 Artificial Intellicenge. Foundations of Computational Agents&lt;/span&gt;&lt;span&gt;" title="&lt;span&gt;Tema 3 Artificial Intellicenge. Foundations of Computational Agents&lt;/span&gt;&lt;/span&gt;&lt;span&gt;" fb_type="iframe" url="&lt;span&gt;http://artint.info/html/ArtInt_46.html&lt;/span&gt;&lt;/span&gt;&lt;span&gt;"]]&lt;/span&gt;&lt;/div&gt;</p>